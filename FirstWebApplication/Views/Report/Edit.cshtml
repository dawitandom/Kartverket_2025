@model FirstWebApplication.Models.Report

@{
    ViewData["Title"] = "Edit Draft";
}

<style>
  /* Map size + layout */
  #map {
    height: 600px;
    width: 100%;
    border-radius: 8px;
    border: 2px solid #ddd;
    margin-bottom: 20px;
  }
  .location-btn { margin-bottom: 10px; }
  .coordinates-display {
    background-color: #f8f9fa;
    padding: 10px;
    border-radius: 5px;
    margin-bottom: 15px;
  }

  @@media (max-width: 768px) { #map { height: 450px; } }

  /* Vertical tool panels */
  .map-wrap { position: relative; }

  .map-tools{
    position:absolute; top:16px; right:16px; left:auto;
    display:flex; flex-direction:column; align-items:center; gap:10px;
    padding:10px; background:rgba(255,255,255,.98);
    border-radius:14px; box-shadow:0 10px 28px rgba(0,0,0,.16);
    border:1px solid rgba(0,0,0,.08); backdrop-filter: blur(6px);
    z-index: 1000;
  }
  .map-tools.secondary{ top:auto; bottom:16px; right:16px; left:auto; }

  .map-tools hr{
    width:70%; border:none; border-top:1px solid rgba(0,0,0,.08); margin:4px 0;
  }

  .tool{
    width:64px; height:64px; border-radius:12px; border:1px solid rgba(0,0,0,.08);
    background:#fff; display:grid; place-items:center; cursor:pointer;
    box-shadow:0 4px 14px rgba(0,0,0,.10);
    transition:transform .08s ease, box-shadow .08s ease, background .08s ease;
    color:#111; /* make SVG visible */
  }
  .tool:hover{ transform:translateY(-2px); background:#f6f7fb; }
  .tool.active{ outline:3px solid #4c8bf5; }
  .tool.danger{ background:linear-gradient(180deg,#dc3545,#a71d2a); color:#fff; border:none; }

  /* SVG size inside buttons */
  .map-tools .tool svg { width:28px; height:28px; }

  @@media (max-width: 480px){
    .map-tools{ top:12px; right:12px; left:auto; padding:8px; border-radius:12px; }
    .map-tools.secondary{ bottom:12px; right:12px; left:auto; }
    .tool{ width:52px; height:52px; }
    .map-tools .tool svg { width:24px; height:24px; }
  }
  .tool.disabled{
    opacity:.45;
    pointer-events:none; /* blokker klikk */
    filter: grayscale(0.6);
  }

  /* Info button styles (updated to match Scheme.cshtml) */
  /* Info button styles */
  .info-btn{
    --ring-color: var(--kartverket-green, #1f8b4c);
    width:24px;     /* mindre sirkel */
    height:24px;
    box-sizing: border-box;
    border-radius:50%;
    background:transparent;
    border:2px solid var(--ring-color);
    padding:0;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    position:relative;
    color:var(--ring-color);
    font-weight:600;
    font-size:10px;   /* ring/ikon base-size */
    line-height:1;
    cursor:pointer;
    transition:box-shadow .12s ease, transform .06s ease;
  }

  /* inner white circle */
  .info-btn::before{
    content: "";
    position: absolute;
    inset: 4px;      /* mindre indre sirkel */
    background: #fff;
    border-radius: 50%;
    z-index: 0;
    pointer-events: none;
  }

  /* text (“i”) */
  .info-btn > span {
    z-index: 1;
    position: relative;
    font-size: 10px;  /* gjør “i” mindre */
    transform: translateY(-1px);
  }

  .info-btn:focus, .info-btn:hover {
    box-shadow: 0 4px 12px rgba(31,139,76,0.18); /* nedskalert */
    outline: none;
    transform: translateY(-1px);
  }

  /* Popover max width */
  .popover { max-width: 520px; }


</style>

<div class="container mt-4">
  <h2>Edit Draft</h2>


  @if (!ViewData.ModelState.IsValid)
  {
      <div class="alert alert-danger" role="alert">
          <h5>Please correct the following errors:</h5>
          <div asp-validation-summary="All"></div>
      </div>
  }

  <form asp-action="Edit" method="post">
    @Html.AntiForgeryToken()
    <input asp-for="ReportId" type="hidden" />
    <input asp-for="UserId" type="hidden" />

    <!-- 1) LOCATION -->
    <div class="card mb-4">
      <div class="card-header">
        <h5>Location</h5>
      </div>
      <div class="card-body">
        <button type="button" id="useMyLocation" class="btn btn-success location-btn">Use My Current Location</button>
        <button type="button" id="clearLocation" class="btn btn-outline-secondary location-btn">Clear Location</button>

        <div class="coordinates-display">
          <strong>Selected Coordinates:</strong>
          <span id="coordsDisplay">Click on the map or use your location</span>
        </div>

        <!-- Map + custom vertical toolbars (icons only) -->
        <div class="map-wrap">
          <!-- Right (top) tools -->
          <div class="map-tools">
            <button type="button" id="tool-line"  class="tool" title="Line">
              <text>
                <svg viewBox="0 0 24 24"><path d="M4 18l6-6 4 4 6-10" fill="none" stroke="currentColor" stroke-width="2"/></svg>
              </text>
            </button>
            <button type="button" id="tool-circle" class="tool" title="Circle">
              <text>
                <svg viewBox="0 0 24 24">
                  <circle cx="12" cy="12" r="7" fill="none" stroke="currentColor" stroke-width="2" />
                </svg>
              </text>
            </button>
            <button type="button" id="tool-poly"  class="tool" title="Polygon">
              <text>
                <svg viewBox="0 0 24 24"><path d="M7 2l10 2 4 8-6 8H7L3 12z" fill="none" stroke="currentColor" stroke-width="2"/></svg>
              </text>
            </button>
            <button type="button" id="tool-rect"  class="tool" title="Rectangle">
              <text>
                <svg viewBox="0 0 24 24"><rect x="4" y="6" width="16" height="12" stroke="currentColor" fill="none" stroke-width="2"/></svg>
              </text>
            </button>
          </div>

          <!-- Right (bottom) tools: Edit / Finish / Delete -->
          <div class="map-tools secondary">
            <button type="button" id="tool-edit" class="tool" title="Edit">
              <text>
                <svg viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75z" fill="currentColor"/></svg>
              </text>
            </button>
            <button type="button" id="tool-edit-done" class="tool" title="Finish edit">
              <text>
                <svg viewBox="0 0 24 24"><path d="M5 13l4 4L19 7" stroke="currentColor" stroke-width="2" fill="none"/></svg>
              </text>
            </button>
            <button type="button" id="tool-del"  class="tool danger" title="Delete">
              <text>
                <svg viewBox="0 0 24 24"><path d="M3 6h18M8 6V4h8v2M6 6l1 14h10l1-14" fill="none" stroke="currentColor" stroke-width="2"/></svg>
              </text>
            </button>
          </div>

          <!-- SINGLE map element -->
          <div id="map"></div>
        </div>

        <!-- Hidden felter som binder til modellen -->
        <input asp-for="Latitude"  type="hidden" id="latitudeHidden" />
        <input asp-for="Longitude" type="hidden" id="longitudeHidden" />
        <input asp-for="Geometry" type="hidden" id="geometryHidden" />


        <!-- Manuelle koordinater -->
        <div class="row mt-3">
          <div class="col-md-6">
            <label class="control-label">Latitude (manual)</label>
            <input type="text" class="form-control" id="latitudeManual" placeholder="59.911491" />
            <span asp-validation-for="Latitude" class="text-danger"></span>
          </div>
          <div class="col-md-6">
            <label class="control-label">Longitude (manual)</label>
            <input type="text" class="form-control" id="longitudeManual" placeholder="10.757933" />
            <span asp-validation-for="Longitude" class="text-danger"></span>
          </div>
        </div>
      </div>
    </div>

    <!-- 2) Height -->
    <div class="form-group mb-3">
      <label asp-for="HeightFeet" class="control-label">Height (feet)</label>
      <input asp-for="HeightFeet" class="form-control" type="number" min="0" max="20000" step="1" inputmode="numeric" placeholder="e.g. 500" />
      <span asp-validation-for="HeightFeet" class="text-danger"></span>
      <small class="form-text text-muted">Optional — enter a whole number between 0 and 20,000</small>
    </div>

    <!-- 3) OBSTACLE TYPE -->
    <div class="form-group mb-3">
      <div class="d-flex align-items-center gap-2 mb-1">
        <label asp-for="ObstacleId" class="control-label">Obstacle Type *</label>
        <button id="obstaclePopoverBtn" type="button" class="info-btn" data-bs-html="true" aria-label="Obstacle types information" title="Obstacle types">
          <span>i</span>
        </button>
      </div>

      <select asp-for="ObstacleId" class="form-control" asp-items="ViewBag.ObstacleTypes">
        <option value="">-- Select Obstacle Type --</option>
      </select>
      <span asp-validation-for="ObstacleId" class="text-danger"></span>
    </div>

    <!-- 4) DESCRIPTION -->
    <div class="form-group mb-3">
      <label asp-for="Description" class="control-label">Description *</label>
      <textarea asp-for="Description" class="form-control" rows="5" placeholder="Describe the obstacle in detail (minimum 10 characters)"></textarea>
      <span asp-validation-for="Description" class="text-danger"></span>
      <small class="form-text text-muted">Minimum 10 characters, maximum 5000</small>
    </div>

    <!-- 5) KNAPPER -->
    <div class="form-group mt-4 d-flex gap-2">
      <button type="submit" name="submitAction" value="save" class="btn btn-secondary btn-lg">Save changes</button>
      <button type="submit" name="submitAction" value="submit" class="btn btn-primary btn-lg">Submit</button>
      <a asp-action="MyReports" class="btn btn-outline-secondary btn-lg">Back</a>
    </div>
  </form>
</div>

@section Scripts {
  <partial name="_ValidationScriptsPartial" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <script src="https://cdn.jsdelivr.net/npm/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

  <script>
    // --- INIT KART ---
    const map = L.map('map').setView([59.911491, 10.757933], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors', maxZoom: 19
    }).addTo(map);

    const drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);

    const drawStyles = {
      polygon:   { color:'#FF6F61', weight:3, opacity:0.95, fillColor:'#FFB6A6', fillOpacity:0.35 },
      rectangle: { color:'#FF6F61', weight:3, opacity:0.95, fillColor:'#FFB6A6', fillOpacity:0.35 },
      circle: { color:'#FF6F61', weight:3, opacity:0.95, fillColor:'#FFB6A6', fillOpacity:0.35 },
      polyline:  { color:'#0055FF', weight:4, opacity:0.95 }
    };

    // EGEN handlers (programmatisk)
    const handlers = {
      marker:  new L.Draw.Marker(map),
      line:    new L.Draw.Polyline(map,  { shapeOptions: drawStyles.polyline }),
      rect:    new L.Draw.Rectangle(map, { shapeOptions: drawStyles.rectangle }),
      circle:  new L.Draw.Circle(map,  { shapeOptions: drawStyles.circle }),
      polygon: new L.Draw.Polygon(map,   { shapeOptions: drawStyles.polygon }),
      edit:    new L.EditToolbar.Edit(map, { featureGroup: drawnItems, selectedPathOptions:{ maintainColor:true } }),
      del:     new L.EditToolbar.Delete(map, { featureGroup: drawnItems })
    };
    
  
    function disableAllModes(){
      handlers.marker.disable();
      handlers.line.disable();
      handlers.rect.disable();
      handlers.polygon.disable();
      handlers.circle.disable();
      handlers.edit.disable();
      handlers.del.disable();
    }
    
    function setActive(btn){
      document.querySelectorAll('.map-tools .tool').forEach(b => b.classList.remove('active'));
      if (btn) btn.classList.add('active');
    }

    let marker = null; // visuell pekepinne midt i objektet / på punkt

    // ---- PRESISE SENTRE ----
    function centroidOfPolygon(latlngs) {
      const pts = latlngs.map(p => ({x: p.lng, y: p.lat}));
      const n = pts.length;
      let twiceArea = 0, cx = 0, cy = 0;
      for (let i = 0; i < n; i++) {
        const j = (i + 1) % n;
        const cross = pts[i].x * pts[j].y - pts[j].x * pts[i].y;
        twiceArea += cross;
        cx += (pts[i].x + pts[j].x) * cross;
        cy += (pts[i].y + pts[j].y) * cross;
      }
      if (Math.abs(twiceArea) < 1e-12) {
        let slat = 0, slng = 0;
        latlngs.forEach(p => { slat += p.lat; slng += p.lng; });
        return L.latLng(slat / latlngs.length, slng / latlngs.length);
      }
      cx /= (3 * twiceArea);
      cy /= (3 * twiceArea);
      return L.latLng(cy, cx);
    }

    function midpointOfPolyline(latlngs) {
      if (latlngs.length === 1) return latlngs[0];
      let total = 0; const seg = [];
      for (let i = 0; i < latlngs.length - 1; i++) {
        const d = map.distance(latlngs[i], latlngs[i+1]);
        seg.push(d); total += d;
      }
      const target = total / 2; let acc = 0;
      for (let i = 0; i < seg.length; i++) {
        if (acc + seg[i] >= target) {
          const t = seg[i] ? (target - acc) / seg[i] : 0;
          const A = latlngs[i], B = latlngs[i+1];
          return L.latLng(A.lat + (B.lat - A.lat)*t, A.lng + (B.lng - A.lng)*t);
        }
        acc += seg[i];
      }
      return latlngs[latlngs.length - 1];
    }

    function firstRing(layer) {
      let latlngs = layer.getLatLngs();
      if (Array.isArray(latlngs) && Array.isArray(latlngs[0])) latlngs = latlngs[0];
      return latlngs;
    }

    function layerToGeoJsonCoords(layer) {
      let latlngs = layer.getLatLngs();

      if (!Array.isArray(latlngs)) {
        if (typeof layer.getLatLng === 'function') {
          const ll = layer.getLatLng();
          return [[parseFloat(ll.lng.toFixed(9)), parseFloat(ll.lat.toFixed(9))]];
        }
        return [];
      }

      if (Array.isArray(latlngs[0])) {
        const inner = latlngs[0];
        if (inner.length && inner[0].lat !== undefined) {
          latlngs = inner;
        }
      }
      
      if (!latlngs.length || latlngs[0].lat === undefined) {
        return [];
      }

      return latlngs.map(p => [
        parseFloat(p.lng.toFixed(9)),
        parseFloat(p.lat.toFixed(9))
      ]);
    }

    function setGeometryHidden(type, coordsArray, radius = null) {
      const geo = {
        type: type,
        coordinates: coordsArray
      };

      if (radius !== null) {
        geo.radius = radius;
      }

      document.getElementById('geometryHidden').value = JSON.stringify(geo);
    }


    function updateCoordinates(lat, lng) {
      lat = parseFloat(Number(lat).toFixed(9));
      lng = parseFloat(Number(lng).toFixed(9));
      const latStr = lat.toString().replace(',', '.');
      const lngStr = lng.toString().replace(',', '.');

      document.getElementById('latitudeHidden').value = latStr;
      document.getElementById('longitudeHidden').value = lngStr;
      document.getElementById('latitudeManual').value = latStr;
      document.getElementById('longitudeManual').value = lngStr;

      document.getElementById('coordsDisplay').innerHTML =
        `Lat: <strong>${lat.toFixed(6)}</strong>, Lon: <strong>${lng.toFixed(6)}</strong>`;
      if (marker) {
        marker.setLatLng([lat, lng]);
      } else {
        marker = L.marker([lat, lng]).addTo(map);
      }
      map.setView([lat, lng], 13);
    }

    function handleLayerUpdate(layer) {

      // --- POINT ---
      if (layer instanceof L.Marker) {
        const ll = layer.getLatLng();
        updateCoordinates(ll.lat, ll.lng);
        setGeometryHidden('Point', [[ll.lng, ll.lat]]);
        return;
      }

      // --- RECTANGLE ---
      if (layer instanceof L.Rectangle) {
        const center = layer.getBounds().getCenter();
        updateCoordinates(center.lat, center.lng);

        const coords = layerToGeoJsonCoords(layer);
        const geo = {
          type: "Rectangle",
          coordinates: [coords]
        };

        document.getElementById("geometryHidden").value = JSON.stringify(geo);
        document.getElementById("coordsDisplay").innerHTML =
          `Rectangle (${coords.length} corners)`;

        return;
      }

      // --- CIRCLE ---
      if (layer instanceof L.Circle) {
        const c = layer.getLatLng();
        const radius = layer.getRadius();

        updateCoordinates(c.lat, c.lng);

        const coords = [[
          parseFloat(c.lng.toFixed(9)),
          parseFloat(c.lat.toFixed(9))
        ]];

        const geo = {
          type: "Circle",
          coordinates: coords,
          radius: radius
        };

        document.getElementById("geometryHidden").value = JSON.stringify(geo);
        document.getElementById("coordsDisplay").innerHTML =
          `Circle center: <strong>${c.lat.toFixed(6)}, ${c.lng.toFixed(6)}</strong> – Radius: <strong>${Math.round(radius)} m</strong>`;

        return;
      }

      // --- POLYGON ---
      if (layer instanceof L.Polygon) {
        const ring = layer.getLatLngs()[0];
        const center = centroidOfPolygon(ring);

        updateCoordinates(center.lat, center.lng);

        const coords = layerToGeoJsonCoords(layer);

        const geo = {
          type: "Polygon",
          coordinates: [coords]
        };

        document.getElementById("geometryHidden").value = JSON.stringify(geo);
        document.getElementById("coordsDisplay").innerHTML =
          `Polygon with ${coords.length} points`;

        return;
      }

      // --- LINE ---
      if (layer instanceof L.Polyline) {
        let latlngs = layer.getLatLngs();
        if (Array.isArray(latlngs) && Array.isArray(latlngs[0]) && latlngs[0].lat === undefined)
          latlngs = latlngs[0];

        const mid = midpointOfPolyline(latlngs);
        updateCoordinates(mid.lat, mid.lng);

        const coords = layerToGeoJsonCoords(layer);

        setGeometryHidden('LineString', coords);

        document.getElementById('coordsDisplay').innerHTML =
          `Line: ${coords.length} points (midpoint shown)`;

        return;
      }
}


    // --- KNAPP-BINDINGER (ekstern toolbar) ---
    document.getElementById('tool-line').addEventListener('click', e => {
      disableAllModes(); handlers.line.enable(); setActive(e.currentTarget);
    });
    document.getElementById('tool-rect').addEventListener('click', e => {
      disableAllModes(); handlers.rect.enable(); setActive(e.currentTarget);
    });
    document.getElementById('tool-poly').addEventListener('click', e => {
      disableAllModes(); handlers.polygon.enable(); setActive(e.currentTarget);
    });
    document.getElementById('tool-circle').addEventListener('click', e => {
      disableAllModes(); handlers.circle.enable(); setActive(e.currentTarget);
    });
    document.getElementById('tool-edit').addEventListener('click', e => {
      disableAllModes(); handlers.edit.enable(); setActive(e.currentTarget);
    });
    document.getElementById('tool-edit-done').addEventListener('click', () => {
      handlers.edit.disable(); setActive(null); // avslutt redigering
    });
    document.getElementById('tool-del').addEventListener('click', e => {
      disableAllModes(); handlers.del.enable(); setActive(e.currentTarget);
    });
    
    // Rydd aktiv-state når noe er ferdig
    map.on('draw:created draw:edited draw:deleted', () => setActive(null));

    // --- HENDELSER ---
    map.on(L.Draw.Event.CREATED, function (e) {
      drawnItems.clearLayers();
      const layer = e.layer;
      drawnItems.addLayer(layer);

      if (layer instanceof L.Polygon || layer instanceof L.Rectangle) {
        if (typeof layer.setStyle === 'function') layer.setStyle(drawStyles.polygon);
      } else if (layer instanceof L.Polyline) {
        if (typeof layer.setStyle === 'function') layer.setStyle(drawStyles.polyline);
      }
      handleLayerUpdate(layer);
    });

    // Live oppdatering under redigering
    map.on('draw:editmove', function(e){
      if (e.layer) handleLayerUpdate(e.layer);
    });
    map.on('draw:editvertex', function(e){
      if (e.layers && typeof e.layers.eachLayer === 'function') {
        e.layers.eachLayer(l => handleLayerUpdate(l));
      } else if (e.layer) {
        handleLayerUpdate(e.layer);
      }
    });

    // Ferdig redigert
    map.on(L.Draw.Event.EDITED, function (e) {
      e.layers.eachLayer(function (layer) {
        handleLayerUpdate(layer);
      });
    }); 

    // Slettet
    map.on(L.Draw.Event.DELETED, function () {
      drawnItems.clearLayers();
      document.getElementById('latitudeHidden').value = '';
      document.getElementById('longitudeHidden').value = '';
      document.getElementById('latitudeManual').value = '';
      document.getElementById('longitudeManual').value = '';
      document.getElementById('geometryHidden').value = '';
      document.getElementById('coordsDisplay').innerHTML = 'Click on the map or use your location';
      if (marker) { map.removeLayer(marker); marker = null; }
    });

    // Klikk i kartet = enkel posisjon
    map.on('click', function(e) {
      drawnItems.clearLayers();
      document.getElementById('geometryHidden').value = '';
      updateCoordinates(e.latlng.lat, e.latlng.lng);
    });

    // "Bruk min posisjon"
    document.getElementById('useMyLocation').addEventListener('click', function() {
      if (!navigator.geolocation) { alert('Geolocation is not supported by your browser.'); return; }
      const originalText = this.innerHTML;
      this.innerHTML = 'Getting location...'; this.disabled = true;

      navigator.geolocation.getCurrentPosition(
        (pos) => {
          drawnItems.clearLayers();
          document.getElementById('geometryHidden').value = '';
          updateCoordinates(pos.coords.latitude, pos.coords.longitude);
          this.innerHTML = originalText; this.disabled = false;
        },
        (err) => {
          this.innerHTML = originalText; this.disabled = false;
          alert('Could not get your location. Please check your browser permissions.');
          console.error(err);
        },
        { enableHighAccuracy: true, timeout: 6000 }
      );
    });

    // "Clear"
    document.getElementById('clearLocation').addEventListener('click', function() {
      document.getElementById('latitudeHidden').value = '';
      document.getElementById('longitudeHidden').value = '';
      document.getElementById('latitudeManual').value = '';
      document.getElementById('longitudeManual').value = '';
      document.getElementById('geometryHidden').value = '';
      document.getElementById('coordsDisplay').innerHTML = 'Click on the map or use your location';
      if (marker) { map.removeLayer(marker); marker = null; }
      drawnItems.clearLayers();
    });

    // Manuelle inputs → kart
    document.getElementById('latitudeManual').addEventListener('change', function() {
      const lat = parseFloat(this.value.replace(',', '.'));
      const lng = parseFloat(document.getElementById('longitudeManual').value.replace(',', '.'));
      if (!isNaN(lat) && !isNaN(lng)) {
        drawnItems.clearLayers();
        document.getElementById('geometryHidden').value = '';
        updateCoordinates(lat, lng);
      }
    });
    document.getElementById('longitudeManual').addEventListener('change', function() {
      const lat = parseFloat(document.getElementById('latitudeManual').value.replace(',', '.'));
      const lng = parseFloat(this.value.replace(',', '.'));
      if (!isNaN(lat) && !isNaN(lng)) {
        drawnItems.clearLayers();
        document.getElementById('geometryHidden').value = '';
        updateCoordinates(lat, lng);
      }
    });

    // Preload figur når vi redigerer en lagret rapport
    document.addEventListener('DOMContentLoaded', () => {
      const geomField = document.getElementById('geometryHidden');
      const geomValue = geomField ? geomField.value : '';

      // Hvis vi har lagret Geometry (linje, sirkel, polygon, osv)
      if (geomValue) {
        let geo;
        try {
          geo = JSON.parse(geomValue);
        } catch (e) {
          console.error('Could not parse Geometry JSON:', e);
          geo = null;
        }

        if (!geo || !geo.type) {
          console.warn('Geometry missing type – falls back to point');
          preloadPointFromLatLon();
          return;
        }

        // Hjelpefunksjon for å lage LatLng fra [lng, lat]
        const toLatLng = (coord) => L.latLng(coord[1], coord[0]);

        let layer = null;

        switch (geo.type) {
          case 'Point': {
            // Expected: coordinates: [[lng, lat]]
            if (Array.isArray(geo.coordinates) && geo.coordinates[0]) {
              const [lng, lat] = geo.coordinates[0];
              layer = L.marker([lat, lng]);
            }
            break;
          }

          case 'LineString': {
            // Expected: coordinates: [[lng, lat], [lng, lat], ...]
            const latlngs = (geo.coordinates || []).map(toLatLng);
            layer = L.polyline(latlngs, drawStyles.polyline);
            break;
          }

          case 'Polygon':
          case 'Rectangle': {
            const ring = geo.coordinates?.[0] || [];
            const latlngs = ring.map(toLatLng);
            layer = L.rectangle(latlngs, drawStyles.rectangle);
            break;
          }

          case 'Circle': {
            const coord = geo.coordinates?.[0];
            if (Array.isArray(coord)) {
              const [lng, lat] = coord;
              const radius = geo.radius || 200;
              layer = L.circle([lat, lng], {
                radius: radius,
                ...drawStyles.circle
              });
            }
            break;
          }
        }

        if (layer) {
          drawnItems.clearLayers();
          drawnItems.addLayer(layer);
          handleLayerUpdate(layer); // denne oppdaterer coords + tekst
        } else {
          console.warn('Could not build figure from Geometry – falls back to point');
          preloadPointFromLatLon();
        }
      } else {
        preloadPointFromLatLon();
      }
});

    // Hjelpefunksjon: last inn bare punkt fra Latitude/Longitude
    function preloadPointFromLatLon() {
      const latValRaw = document.getElementById('latitudeHidden').value;
      const lonValRaw = document.getElementById('longitudeHidden').value;

      if (latValRaw && lonValRaw) {
        const latVal = parseFloat(latValRaw.replace(',', '.'));
        const lonVal = parseFloat(lonValRaw.replace(',', '.'));

        if (!Number.isNaN(latVal) && !Number.isNaN(lonVal)) {
          updateCoordinates(latVal, lonVal);
        }
      }
}


  </script>

  <script>
    // Obstacle info popover (Bootstrap)
    document.addEventListener('DOMContentLoaded', () => {
      const btn = document.getElementById('obstaclePopoverBtn');
      if (!btn || typeof bootstrap === 'undefined') return;

      const contentHtml = `
        <p>Select the type that best matches the obstacle. If unsure, pick <strong>Other</strong> and describe it.</p>
        <ul>
          <li><strong>Tower</strong> - large, permanent tower structures (e.g., observation towers, communication towers).</li>
          <li><strong>Crane</strong> - construction cranes, usually temporary structures used for lifting.</li>
          <li><strong>Building</strong> - permanent buildings or large man-made structures.</li>
          <li><strong>Power line</strong> - overhead electrical lines carrying power.</li>
          <li><strong>Mast</strong> - tall structures used for telecom, radio or observation purposes.</li>
          <li><strong>Other</strong> — anything not covered by the categories above (e.g., balloons, temporary objects, unusual structures).</li>
        </ul>
      `;

      const pop = new bootstrap.Popover(btn, { content: contentHtml, html: true, trigger: 'manual', sanitize: false });

      btn.addEventListener('click', (e) => {
        e.preventDefault();
        if (document.querySelector('.popover')) {
          pop.hide();
        } else {
          pop.show();
        }
      });

      function hideIfOutside(ev) {
        const popEl = document.querySelector('.popover');
        if (!popEl) return;
        if (btn.contains(ev.target) || popEl.contains(ev.target)) return;
        pop.hide();
      }

      document.addEventListener('click', hideIfOutside);
      document.addEventListener('keydown', (ev) => {
        if (ev.key === 'Escape' || ev.key === 'Esc') {
          if (document.querySelector('.popover')) pop.hide();
        }
      });
    });
  </script>
}

